# OS course design

[TOC]

## Lab: Xv6 and Unix utilities

本实验的主要目的是熟悉xv6以及其系统调用。



### 1. Boot xv6 (easy）

#### 1) 实验目的

获取实验室的xv6源代码并切换到`util`分支，构建并运行xv6。

#### 2) 实验步骤

1. 将`xv6-labs-2021`克隆至本地，创建并切换至`util`分支：

   ```bash
   $ git clone git://g.csail.mit.edu/xv6-labs-2021
   Cloning into 'xv6-labs-2021'...
   ...
   $ cd xv6-labs-2021
   $ git checkout util
   ```

2. 构建并运行xv6：

   ```bash
   $ make qemu
   ```

#### 3) 实验中遇到的问题和解决方法

无。

#### 4) 实验心得

1. 学会了如何切换分支。
2. 学会了使用`qemu`运行xv6环境。



### 2. sleep (easy）

#### 1) 实验目的

实现xv6的UNIX程序`sleep`：暂停用户指定的计时数。

#### 2) 实验步骤

1. 在user目录下创建`sleep.c`。

2. 在`sleep.c`中编写程序实现功能：

   - 获取用户提供的参数作为暂停的时钟周期数。
   - 使用`sleep()`系统调用暂停相应的周期数。

3. 在Makefile文件的UPROGS中添加$U/_sleep\。

4. 运行xv6并测试sleep命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ sleep 10
   (nothing happens for a little while)
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util sleep
   ```

   或是

   ```bash
   $ make GRADEFLAGS=sleep grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1**：

不了解如何获取用户输入的参数。

**解决方法**：

通过查询互联网资料了解了`main`函数的两个参数`argc`、`argv`的含义。

> argc：表示运行程序的时候给`main`函数传递了几个参数。
>
> argv：用来存储`argc`个字符串，每个字符串就是给`main`函数传的一个参数。

#### 4) 实验心得

1. 学会了如何处理命令行参数。
2. 学会了`sleep`系统调用的使用方法。



### 3. pingpong (easy)

#### 1) 实验目的

实现xv6的UNIX程序`pingpong`：在两个进程间通过一对管道来传递数据。

#### 2) 实验步骤

1. 在user目录下创建`pingpong.c`。

2. 在`pingpong.c`中编写程序实现功能：

   - 使用`pipe()`系统调用创建一对管道`p2c`和`c2p`用来在两个进程间传递数据。
   - 使用`fork()`系统调用创建子进程。
   - 父进程：
     - 使用`close()`系统调用，关闭子进程向父进程的读和写。
     - 使用`write()`系统调用，向管道`p2c`中写入数据。
     - 使用`read()`系统调用，从管道`c2p`中读取数据并打印信息。
     - 使用`wait()`系统调用，等待子进程结束。
   - 子进程：
     - 使用`close()`系统调用，关闭父进程向子进程的读和写。
     - 使用`read()`系统调用，从管道`p2c`中读取数据并打印信息。
     - 使用`write()`系统调用，向管道`c2p`中写入数据。

3. 在Makefile文件的UPROGS中添加$U/_pingopng\。

4. 运行xv6并测试sleep命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ pingpong
   4: received ping
   3: received pong
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util pingpong
   ```

   或是

   ```bash
   $ make GRADEFLAGS=pingpong grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道什么时候应该关闭管道相应的读写。

**解决方法：**

通过查询网络资料，得知何时应关闭管道。

> 当完成对文件的读取或写入操作后，应该关闭文件。这有助于释放系统资源。

#### 4) 实验心得

1. 学会了如何使用`pipe()`、`fork()`、`close()`、`write()`、`read()`等系统调用。
2. 简单了解了父子进程间的通信。



### 4. primes (moderate)/(hard)

#### 1) 实验目的

实现简易版的xv6的UNIX程序`primes`：寻找小于等于35的所有素数

#### 2) 实验步骤

1. 在user目录下创建`primes.c`。

2. 在`primed.c`中编写程序实现功能：

   - 使用`pipe()`系统调用，创建管道用来通信。
   - 将0-35写入管道中。
   - 使用`fork()`系统调用创建子进程。
   - 父进程：
     - 使用`close()`系统调用，关闭读和写。
     - 使用`wait()`系统调用，等待子进程结束。
   - 子进程：
     - 使用`close()`系统调用，关闭左侧的写。
     - 使用`read()`系统调用，从左侧管道读取数据并打印信息。
     - 使用`pipe()`系统调用，创建右侧管道。
     - 筛选掉左侧第一个数的倍数。
     - 使用`write()`系统调用，向右侧管道中写入剩余的数据。
   - 循环创建子进程，直至左侧没有数据。

3. 在Makefile文件的UPROGS中添加$U/_primes\。

4. 运行xv6并测试primes命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ primes
   prime 2
   prime 3
   prime 5
   prime 7
   prime 11
   prime 13
   prime 17
   prime 19
   prime 23
   prime 29
   prime 31
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util primes
   ```

   或是

   ```bash
   $ make GRADEFLAGS=primes grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道该怎样利用创建子进程来实现循环。

**解决方法：**

通过查询网络资料解决了该问题。

> 在子进程调用的函数中再次使用`fork()`函数创建新的子进程。

#### 4) 实验心得

1. 学会了如何通过创建子进程来实现循环。
2. 掌握了一种新的求素数的算法。



### 5. find (moderate)

#### 1) 实验目的

实现xv6的UNIX程序`find`：用户指定目录与文件名，寻找该目录下的所有的该文件名的文件。

#### 2) 实验步骤

1. 在user目录下创建`find.c`。

2. 在`find.c`中编写程序实现功能：

   - 获取用户输入的参数作为目录名与文件名。
   - 使用`open()`和`fstat()`系统调用，打开目录并获取信息。
   - 使用`read()`系统调用，读取该目录下所有的目录与文件。
   - 文件：
     - 判断文件名与指定文件名是否相同。
   - 目录：
     - 递归查询。
   - 循环上述步骤直至读取完毕。

3. 在Makefile文件的UPROGS中添加$U/_find\。

4. 运行xv6并测试find命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ echo > b
   $ mkdir a
   $ echo > a/b
   $ find . b
   ./b
   ./a/b
   $ 
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util find
   ```

   或是

   ```bash
   $ make GRADEFLAGS=find grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道如何对文件进行处理。

**解决方法：**

通过查看xv6资料中的其他程序的代码，解决了该问题。

> 通过`open()`和`fstat()`系统调用来打开文件并获取文件信息。

#### 4) 实验心得

1. 学会了如何使用open()和fstat()系统调用来对文件进行操作。



### 6. xargs (moderate)

#### 1) 实验目的

实现xv6的UNIX程序`xargs`：获取标准输入，并将输入作为命令的参数。

#### 2) 实验步骤

1. 在user目录下创建`xargs.c`。

2. 在`xargs.c`中编写程序实现功能：

   - 获取用户输入的参数作为将要执行的命令。
   - 使用`read()`系统调用，从标准输入中获取数据。
   - 每次读取一个数据，遇到换行符时，使用`exec()`系统调用，执行新的程序。

3. 在Makefile文件的UPROGS中添加$U/_xargs\。

4. 运行xv6并测试xargs命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ sh < xargstest.sh
   $ $ $ $ $ $ hello
   hello
   hello
   $ $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util xargs
   ```

   或是

   ```bash
   $ make GRADEFLAGS=xargs grade
   ```

#### 3) 实验中遇到的问题与解决方法

无

#### 4) 实验心得

1. 学会了`exec()`系统调用的使用方法。



## Lab: system calls

本实验的主要目的是为xv6添加一些新的系统调用，了解其工作原理。



### 1. System call tracing (moderate）

#### 1) 实验目的

实现xv6系统调用`trace`：跟踪系统调用。

#### 2) 实验步骤

1. 在`user/user.h`中添加`trace`的函数声明：

   ```c
   int trace(int);
   ```

2. 在`user/usys.pl`中添加以下语句，以更新汇编语言`usys.S`：

   ```perl
   entry("trace");
   ```

3. 在`kernel/syscall.h`中添加`trace`的系统调用号：

   ```c
   #define SYS_trace  22
   ```

4. 在`kernel/syscall.c`的函数指针数组中加入trace系统调用：

   ```c
   static uint64 (*syscalls[])(void) = {
   	...
   	[SYS_trace]   sys_trace,
   };
   ```

5. 在`kernel/syscall.c`中加入`sys_trace`的函数声明：

   ```c
   extern uint64 sys_trace(void);
   ```

6. 在`kernel/proc.h`中的`proc`结构体中新增一个变量`mask`，用来记录要追踪的系统调用：

   ```c
   struct proc {
   	...
   	int mask;                    // Trace Mask
   };
   ```

7. 在`kernel/sysproc.c`中添加`sys_trace`的函数实现：

   ```c
   uint64
   sys_trace(void)
   {
       int mask;
       
   	if (argint(0, &mask) < 0)
       	return -1;
     	myproc()->mask = mask;
   
     	return 0;
   }
   ```

8. 在`kernel/syscall.c`中新增一个数组用来记录系统调用的名称：

   ```c
   static char* syscalls_name[] = {
     [SYS_fork]    "fork",
     [SYS_exit]    "exit",
     [SYS_wait]    "wait",
     [SYS_pipe]    "pipe",
     [SYS_read]    "read",
     [SYS_kill]    "kill",
     [SYS_exec]    "exec",
     [SYS_fstat]   "fstat",
     [SYS_chdir]   "chdir",
     [SYS_dup]     "dup",
     [SYS_getpid]  "getpid",
     [SYS_sbrk]    "sbrk",
     [SYS_sleep]   "sleep",
     [SYS_uptime]  "uptime",
     [SYS_open]    "open",
     [SYS_write]   "write",
     [SYS_mknod]   "mknod",
     [SYS_unlink]  "unlink",
     [SYS_link]    "link",
     [SYS_mkdir]   "mkdir",
     [SYS_close]   "close",
     [SYS_trace]   "trace",
   };
   ```

9. 在`kernel/syscall.c`中的`syscall`函数中加入输出语句：

   ```C
   void
   syscall(void)
   {
     ...
     if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
      	...
       if ((1 << num) & p->mask) {
         printf("%d: syscall %s -> %d\n", p->pid, syscalls_name[num], p->trapframe->a0);
       }
     } else {
       ...
     }
   }
   ```

10. 在`kernel/proc.c`中的`fork`函数中加入复制`mask`语句：

    ```C
    int
    fork(void)
    {
        ...
        np->mask = p->mask;
        ...
    }
    ```

11. 在Makefile文件的UPROGS中添加$U/_trace\。

12. 运行xv6并测试trace命令：

    ```bash
    $ make qemu
    ...
    init: starting sh
    $ trace 32 grep hello README
    3: syscall read -> 1023
    3: syscall read -> 966
    3: syscall read -> 70
    3: syscall read -> 0
    $
    $ trace 2147483647 grep hello README
    4: syscall trace -> 0
    4: syscall exec -> 3
    4: syscall open -> 3
    4: syscall read -> 1023
    4: syscall read -> 966
    4: syscall read -> 70
    4: syscall read -> 0
    4: syscall close -> 0
    $
    $ grep hello README
    $
    $ trace 2 usertests forkforkfork
    usertests starting
    test forkforkfork: 407: syscall fork -> 408
    408: syscall fork -> 409
    409: syscall fork -> 410
    410: syscall fork -> 411
    409: syscall fork -> 412
    410: syscall fork -> 413
    409: syscall fork -> 414
    411: syscall fork -> 415
    ...
    $
    ```

13. 测试程序得分：

    ```bash
    $ ./grade-lab-syscall trace
    ```

    或是

    ```bash
    $ make GRADEFLAGS=trace grade
    ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不了解程序使用系统调用之后的过程，无从下手。

**解决方法：**

通过查询网络资料，解决了该问题。

> 程序使用系统调用后，`Makefile`会调用`usys.pl`生成`usys.S`，将系统调用号存储在寄存器中以后，通过`ecall`进入`kernel`，运行`syscall`函数，根据寄存器中的值调用`sysproc`中相应的函数。

#### 4) 实验心得

1. 理解了系统调用的执行过程。
2. 对xv6的结构理解更加深入。



### 2. Sysinfo (moderate）

#### 1) 实验目的

实现xv6系统调用`sysinfo`：获取当前系统信息。

#### 2) 实验步骤

1. 在`user/user.h`中添加`sysinfo`的函数声明：

   ```c
   ...
   struct sysinfo;
   
   // system calls
   ...
   int sysinfo(struct sysinfo*);
   ```

2. 在`user/usys.pl`中添加以下语句，以更新汇编语言`usys.S`：

   ```perl
   entry("sysinfo");
   ```

3. 在`kernel/syscall.h`中添加`sysinfo`的系统调用号：

   ```c
   #define SYS_sysinfo 23
   ```

4. 在`kernel/syscall.c`的函数指针数组中加入`sysinfo`系统调用：

   ```c
   static uint64 (*syscalls[])(void) = {
   	...
   	[SYS_sysinfo]   sys_sysinfo,
   };
   ```

5. 在`kernel/syscall.c`中加入`sys_sysinfo`的函数声明：

   ```c
   extern uint64 sys_sysinfo(void);
   ```

6. 在`kernel/sysproc.c`中添加`sys_sysinfo`的函数实现：

   ```c
   uint64
   sys_sysinfo(void)
   {
     uint64 addr;
     struct proc* p = myproc();
     struct sysinfo nowinfo;
   
     if (argaddr(0, &addr) < 0) {
       return -1;
     }
   
     //the number of bytes of free memory and the number of processes whose state is not UNUSED
     nowinfo.freemem = freemem();
     nowinfo.nproc = procnum();
   
     if (copyout(p->pagetable, addr, (char*)&nowinfo, sizeof(nowinfo)) < 0) {
       return -1;
     }
   
     return 0;
   }
   ```

7. 在`kernel/defs.h`中添加`freemem`和`procnum`的函数定义：

   ```c
   // kalloc.c
   ...
   uint64          freemem(void);
   ...
   // proc.c
   uint64          procnum(void);
   ```

8. 在`kernel/kalloc.c`中添加`freemem`的函数实现：

   ```c
   uint64
   freemem(void)
   {
     struct run* p = kmem.freelist;
   
     uint64 num = 0;
   
     acquire(&kmem.lock);
     while (p) {
       num++;
       p = p->next;
     }
     release(&kmem.lock);
   
     return num * PGSIZE;
   }
   ```

9. 在`kernel/proc.c`中添加`procnum`的函数实现：

   ```c
   uint64
   procnum(void) {
     struct proc* p;
     uint64 num = 0;
   
     for (p = proc; p < &proc[NPROC]; p++) {
       if (p->state != UNUSED) {
         num++;
       }
     }
   
     return num;
   }
   ```

10. 在Makefile文件的UPROGS中添加$U/_sysinfotest\。

11. 运行xv6并测试sysinfotest命令：

    ```bash
    $ make qemu
    ...
    init: starting sh
    $ sysinfotest
    sysinfotest: start
    sysinfotest: OK
    $
    ```

12. 测试程序得分：

```bash
$ ./grade-lab-syscall sysinfo
```

或是

```bash
$ make GRADEFLAGS=sysinfo grade
```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

在`kernel/kalloc.c`和`kernel/proc.c`之中添加了函数后在`kernel/sysproc.c`中无法调用。

**解决方法：**

通过阅读代码，解决了该问题。

> 应在`kernel/defs.h`中添加函数声明。

#### 4) 实验心得

1. 学会了使用`copyout()`函数将信息拷贝至用户空间。
