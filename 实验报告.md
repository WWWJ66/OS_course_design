# OS course design

[TOC]

## Lab: Xv6 and Unix utilities

本实验的主要目的是熟悉xv6以及其系统调用。



### 1. Boot xv6 (easy）

#### 1) 实验目的

获取实验室的xv6源代码并切换到`util`分支，构建并运行xv6。

#### 2) 实验步骤

1. 将`xv6-labs-2021`克隆至本地，创建并切换至`util`分支：

   ```bash
   $ git clone git://g.csail.mit.edu/xv6-labs-2021
   Cloning into 'xv6-labs-2021'...
   ...
   $ cd xv6-labs-2021
   $ git checkout util
   ```

2. 构建并运行xv6：

   ```bash
   $ make qemu
   ```

#### 3) 实验中遇到的问题和解决方法

无。

#### 4) 实验心得

1. 学会了如何切换分支。
2. 学会了使用`qemu`运行xv6环境。



### 2. sleep (easy）

#### 1) 实验目的

实现xv6的UNIX程序`sleep`：暂停用户指定的计时数。

#### 2) 实验步骤

1. 在user目录下创建`sleep.c`。

2. 在`sleep.c`中编写程序实现功能：

   - 获取用户提供的参数作为暂停的时钟周期数。
   - 使用`sleep()`系统调用暂停相应的周期数。

3. 在Makefile文件的UPROGS中添加$U/_sleep\。

4. 运行xv6并测试sleep命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ sleep 10
   (nothing happens for a little while)
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util sleep
   ```

   或是

   ```bash
   $ make GRADEFLAGS=sleep grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1**：

不了解如何获取用户输入的参数。

**解决方法**：

通过查询互联网资料了解了`main`函数的两个参数`argc`、`argv`的含义。

> argc：表示运行程序的时候给`main`函数传递了几个参数。
>
> argv：用来存储`argc`个字符串，每个字符串就是给`main`函数传的一个参数。

#### 4) 实验心得

1. 学会了如何处理命令行参数。
2. 学会了`sleep`系统调用的使用方法。



### 3. pingpong (easy)

#### 1) 实验目的

实现xv6的UNIX程序`pingpong`：在两个进程间通过一对管道来传递数据。

#### 2) 实验步骤

1. 在user目录下创建`pingpong.c`。

2. 在`pingpong.c`中编写程序实现功能：

   - 使用`pipe()`系统调用创建一对管道`p2c`和`c2p`用来在两个进程间传递数据。
   - 使用`fork()`系统调用创建子进程。
   - 父进程：
     - 使用`close()`系统调用，关闭子进程向父进程的读和写。
     - 使用`write()`系统调用，向管道`p2c`中写入数据。
     - 使用`read()`系统调用，从管道`c2p`中读取数据并打印信息。
     - 使用`wait()`系统调用，等待子进程结束。
   - 子进程：
     - 使用`close()`系统调用，关闭父进程向子进程的读和写。
     - 使用`read()`系统调用，从管道`p2c`中读取数据并打印信息。
     - 使用`write()`系统调用，向管道`c2p`中写入数据。

3. 在Makefile文件的UPROGS中添加$U/_pingopng\。

4. 运行xv6并测试sleep命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ pingpong
   4: received ping
   3: received pong
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util pingpong
   ```

   或是

   ```bash
   $ make GRADEFLAGS=pingpong grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道什么时候应该关闭管道相应的读写。

**解决方法：**

通过查询网络资料，得知何时应关闭管道。

> 当完成对文件的读取或写入操作后，应该关闭文件。这有助于释放系统资源。

#### 4) 实验心得

1. 学会了如何使用`pipe()`、`fork()`、`close()`、`write()`、`read()`等系统调用。
2. 简单了解了父子进程间的通信。



### 4. primes (moderate)/(hard)

#### 1) 实验目的

实现简易版的xv6的UNIX程序`primes`：寻找小于等于35的所有素数

#### 2) 实验步骤

1. 在user目录下创建`primes.c`。

2. 在`primed.c`中编写程序实现功能：

   - 使用`pipe()`系统调用，创建管道用来通信。
   - 将0-35写入管道中。
   - 使用`fork()`系统调用创建子进程。
   - 父进程：
     - 使用`close()`系统调用，关闭读和写。
     - 使用`wait()`系统调用，等待子进程结束。
   - 子进程：
     - 使用`close()`系统调用，关闭左侧的写。
     - 使用`read()`系统调用，从左侧管道读取数据并打印信息。
     - 使用`pipe()`系统调用，创建右侧管道。
     - 筛选掉左侧第一个数的倍数。
     - 使用`write()`系统调用，向右侧管道中写入剩余的数据。
   - 循环创建子进程，直至左侧没有数据。

3. 在Makefile文件的UPROGS中添加$U/_primes\。

4. 运行xv6并测试primes命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ primes
   prime 2
   prime 3
   prime 5
   prime 7
   prime 11
   prime 13
   prime 17
   prime 19
   prime 23
   prime 29
   prime 31
   $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util primes
   ```

   或是

   ```bash
   $ make GRADEFLAGS=primes grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道该怎样利用创建子进程来实现循环。

**解决方法：**

通过查询网络资料解决了该问题。

> 在子进程调用的函数中再次使用`fork()`函数创建新的子进程。

#### 4) 实验心得

1. 学会了如何通过创建子进程来实现循环。
2. 掌握了一种新的求素数的算法。



### 5. find (moderate)

#### 1) 实验目的

实现xv6的UNIX程序`find`：用户指定目录与文件名，寻找该目录下的所有的该文件名的文件。

#### 2) 实验步骤

1. 在user目录下创建`find.c`。

2. 在`find.c`中编写程序实现功能：

   - 获取用户输入的参数作为目录名与文件名。
   - 使用`open()`和`fstat()`系统调用，打开目录并获取信息。
   - 使用`read()`系统调用，读取该目录下所有的目录与文件。
   - 文件：
     - 判断文件名与指定文件名是否相同。
   - 目录：
     - 递归查询。
   - 循环上述步骤直至读取完毕。

3. 在Makefile文件的UPROGS中添加$U/_find\。

4. 运行xv6并测试find命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ echo > b
   $ mkdir a
   $ echo > a/b
   $ find . b
   ./b
   ./a/b
   $ 
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util find
   ```

   或是

   ```bash
   $ make GRADEFLAGS=find grade
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道如何对文件进行处理。

**解决方法：**

通过查看xv6资料中的其他程序的代码，解决了该问题。

> 通过`open()`和`fstat()`系统调用来打开文件并获取文件信息。

#### 4) 实验心得

1. 学会了如何使用open()和fstat()系统调用来对文件进行操作。



### 6. xargs (moderate)

#### 1) 实验目的

实现xv6的UNIX程序`xargs`：获取标准输入，并将输入作为命令的参数。

#### 2) 实验步骤

1. 在user目录下创建`xargs.c`。

2. 在`xargs.c`中编写程序实现功能：

   - 获取用户输入的参数作为将要执行的命令。
   - 使用`read()`系统调用，从标准输入中获取数据。
   - 每次读取一个数据，遇到换行符时，使用`exec()`系统调用，执行新的程序。

3. 在Makefile文件的UPROGS中添加$U/_xargs\。

4. 运行xv6并测试xargs命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ sh < xargstest.sh
   $ $ $ $ $ $ hello
   hello
   hello
   $ $
   ```

5. 测试程序得分：

   ```bash
   $ ./grade-lab-util xargs
   ```

   或是

   ```bash
   $ make GRADEFLAGS=xargs grade
   ```

#### 3) 实验中遇到的问题与解决方法

无

#### 4) 实验心得

1. 学会了`exec()`系统调用的使用方法。



## Lab: system calls

本实验的主要目的是为xv6添加一些新的系统调用，了解其工作原理。



### 1. System call tracing (moderate）

#### 1) 实验目的

实现xv6系统调用`trace`：跟踪系统调用。

#### 2) 实验步骤

1. 在`user/user.h`中添加`trace`的函数声明：

   ```c
   int trace(int);
   ```

2. 在`user/usys.pl`中添加以下语句，以更新汇编语言`usys.S`：

   ```perl
   entry("trace");
   ```

3. 在`kernel/syscall.h`中添加`trace`的系统调用号：

   ```c
   #define SYS_trace  22
   ```

4. 在`kernel/syscall.c`的函数指针数组中加入trace系统调用：

   ```c
   static uint64 (*syscalls[])(void) = {
   	...
   	[SYS_trace]   sys_trace,
   };
   ```

5. 在`kernel/syscall.c`中加入`sys_trace`的函数声明：

   ```c
   extern uint64 sys_trace(void);
   ```

6. 在`kernel/proc.h`中的`proc`结构体中新增一个变量`mask`，用来记录要追踪的系统调用：

   ```c
   struct proc {
   	...
   	int mask;                    // Trace Mask
   };
   ```

7. 在`kernel/sysproc.c`中添加`sys_trace`的函数实现：

   ```c
   uint64
   sys_trace(void)
   {
       int mask;
       
   	if (argint(0, &mask) < 0)
       	return -1;
     	myproc()->mask = mask;
   
     	return 0;
   }
   ```

8. 在`kernel/syscall.c`中新增一个数组用来记录系统调用的名称：

   ```c
   static char* syscalls_name[] = {
     [SYS_fork]    "fork",
     [SYS_exit]    "exit",
     [SYS_wait]    "wait",
     [SYS_pipe]    "pipe",
     [SYS_read]    "read",
     [SYS_kill]    "kill",
     [SYS_exec]    "exec",
     [SYS_fstat]   "fstat",
     [SYS_chdir]   "chdir",
     [SYS_dup]     "dup",
     [SYS_getpid]  "getpid",
     [SYS_sbrk]    "sbrk",
     [SYS_sleep]   "sleep",
     [SYS_uptime]  "uptime",
     [SYS_open]    "open",
     [SYS_write]   "write",
     [SYS_mknod]   "mknod",
     [SYS_unlink]  "unlink",
     [SYS_link]    "link",
     [SYS_mkdir]   "mkdir",
     [SYS_close]   "close",
     [SYS_trace]   "trace",
   };
   ```

9. 在`kernel/syscall.c`中的`syscall`函数中加入输出语句：

   ```C
   void
   syscall(void)
   {
     ...
     if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
      	...
       if ((1 << num) & p->mask) {
         printf("%d: syscall %s -> %d\n", p->pid, syscalls_name[num], p->trapframe->a0);
       }
     } else {
       ...
     }
   }
   ```

10. 在`kernel/proc.c`中的`fork`函数中加入复制`mask`语句：

    ```C
    int
    fork(void)
    {
        ...
        np->mask = p->mask;
        ...
    }
    ```

11. 在Makefile文件的UPROGS中添加$U/_trace\。

12. 运行xv6并测试trace命令：

    ```bash
    $ make qemu
    ...
    init: starting sh
    $ trace 32 grep hello README
    3: syscall read -> 1023
    3: syscall read -> 966
    3: syscall read -> 70
    3: syscall read -> 0
    $
    $ trace 2147483647 grep hello README
    4: syscall trace -> 0
    4: syscall exec -> 3
    4: syscall open -> 3
    4: syscall read -> 1023
    4: syscall read -> 966
    4: syscall read -> 70
    4: syscall read -> 0
    4: syscall close -> 0
    $
    $ grep hello README
    $
    $ trace 2 usertests forkforkfork
    usertests starting
    test forkforkfork: 407: syscall fork -> 408
    408: syscall fork -> 409
    409: syscall fork -> 410
    410: syscall fork -> 411
    409: syscall fork -> 412
    410: syscall fork -> 413
    409: syscall fork -> 414
    411: syscall fork -> 415
    ...
    $
    ```

13. 测试程序得分：

    ```bash
    $ ./grade-lab-syscall trace
    ```

    或是

    ```bash
    $ make GRADEFLAGS=trace grade
    ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不了解程序使用系统调用之后的过程，无从下手。

**解决方法：**

通过查询网络资料，解决了该问题。

> 程序使用系统调用后，`Makefile`会调用`usys.pl`生成`usys.S`，将系统调用号存储在寄存器中以后，通过`ecall`进入`kernel`，运行`syscall`函数，根据寄存器中的值调用`sysproc`中相应的函数。

#### 4) 实验心得

1. 理解了系统调用的执行过程。
2. 对xv6的结构理解更加深入。



### 2. Sysinfo (moderate）

#### 1) 实验目的

实现xv6系统调用`sysinfo`：获取当前系统信息。

#### 2) 实验步骤

1. 在`user/user.h`中添加`sysinfo`的函数声明：

   ```c
   ...
   struct sysinfo;
   
   // system calls
   ...
   int sysinfo(struct sysinfo*);
   ```

2. 在`user/usys.pl`中添加以下语句，以更新汇编语言`usys.S`：

   ```perl
   entry("sysinfo");
   ```

3. 在`kernel/syscall.h`中添加`sysinfo`的系统调用号：

   ```c
   #define SYS_sysinfo 23
   ```

4. 在`kernel/syscall.c`的函数指针数组中加入`sysinfo`系统调用：

   ```c
   static uint64 (*syscalls[])(void) = {
   	...
   	[SYS_sysinfo]   sys_sysinfo,
   };
   ```

5. 在`kernel/syscall.c`中加入`sys_sysinfo`的函数声明：

   ```c
   extern uint64 sys_sysinfo(void);
   ```

6. 在`kernel/sysproc.c`中添加`sys_sysinfo`的函数实现：

   ```c
   uint64
   sys_sysinfo(void)
   {
     uint64 addr;
     struct proc* p = myproc();
     struct sysinfo nowinfo;
   
     if (argaddr(0, &addr) < 0) {
       return -1;
     }
   
     //the number of bytes of free memory and the number of processes whose state is not UNUSED
     nowinfo.freemem = freemem();
     nowinfo.nproc = procnum();
   
     if (copyout(p->pagetable, addr, (char*)&nowinfo, sizeof(nowinfo)) < 0) {
       return -1;
     }
   
     return 0;
   }
   ```

7. 在`kernel/defs.h`中添加`freemem`和`procnum`的函数定义：

   ```c
   // kalloc.c
   ...
   uint64          freemem(void);
   ...
   // proc.c
   uint64          procnum(void);
   ```

8. 在`kernel/kalloc.c`中添加`freemem`的函数实现：

   ```c
   uint64
   freemem(void)
   {
     struct run* p = kmem.freelist;
   
     uint64 num = 0;
   
     acquire(&kmem.lock);
     while (p) {
       num++;
       p = p->next;
     }
     release(&kmem.lock);
   
     return num * PGSIZE;
   }
   ```

9. 在`kernel/proc.c`中添加`procnum`的函数实现：

   ```c
   uint64
   procnum(void) {
     struct proc* p;
     uint64 num = 0;
   
     for (p = proc; p < &proc[NPROC]; p++) {
       if (p->state != UNUSED) {
         num++;
       }
     }
   
     return num;
   }
   ```

10. 在Makefile文件的UPROGS中添加$U/_sysinfotest\。

11. 运行xv6并测试sysinfotest命令：

    ```bash
    $ make qemu
    ...
    init: starting sh
    $ sysinfotest
    sysinfotest: start
    sysinfotest: OK
    $
    ```

12. 测试程序得分：

```bash
$ ./grade-lab-syscall sysinfo
```

或是

```bash
$ make GRADEFLAGS=sysinfo grade
```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

在`kernel/kalloc.c`和`kernel/proc.c`之中添加了函数后在`kernel/sysproc.c`中无法调用。

**解决方法：**

通过阅读代码，解决了该问题。

> 应在`kernel/defs.h`中添加函数声明。

#### 4) 实验心得

1. 学会了使用`copyout()`函数将信息拷贝至用户空间。



# Lab: page tables

本实验的主要目的是了解xv6的页表，加快某些系统调用并检测已访问的页面。



### 1. Speed up system calls (easy）

#### 1) 实验目的

通过页表来加速系统调用，以`getpid()`系统调用为例。

#### 2) 实验步骤

1. 在`kernel/proc.h`的`proc`结构体中添加变量存放 `usyscall` 的地址：

   ```c
   struct proc {
       ...
       // these are private to the process, so p->lock need not be held.
       ...
       struct usyscall *usyscall;   // read-only page for usyscall
   }
   ```

2. 在`kernel/proc.c`的`allocproc`函数中添加以下语句，为`usyscall`分配页面：

   ```c
   static struct proc*
   allocproc(void)
   {
   	...
       // Allocate a usyscall page.
   	if ((p->usyscall = (struct usyscall*)kalloc()) == 0) {
     		freeproc(p);
     		relaease(&p->lock);
     		return 0;
   	}
       ...
   }
   ```

3. 在`kernel/proc.c`的`proc_pagetable`函数中添加以下语句，进行映射：

   ```c
   pagetable_t
   proc_pagetable(struct proc *p)
   {
       ...
       //map one read-only page at USYSCALL
       p->usyscall->pid = p->pid;
   	if (mappages(pagetable, USYSCALL, PGSIZE,
                 	(uint64)(p->usyscall), PTE_R | PTE_U) < 0) {
     		uvmunmap(pagetable, TRAMPOLINE, 1, 0);
     		uvmunmap(pagetable, TRAPFRAME, 1, 0);
     		uvmfree(pagetable, 0);
     		return 0;
   	}
       ...
   }
   ```

4. 在`kernel/proc.c`的`freeproc`函数中添加以下语句，释放分配的页面：

   ```c
   static void
   freeproc(struct proc *p)
   {
       ...
       if (p->usyscall)
     		kfree((void*)p->usyyscall);
   	p->usyscall = 0;
       ...
   }
   ```

5. 在`kernel/proc.c`的`proc_freepagetable`函数中添加以下语句，释放分配的页表：

   ```c
   void
   proc_freepagetable(pagetable_t pagetable, uint64 sz)
   {
       ...
       uvmunmap(pagetable, USYSCALL, 1, 0);
       ...
   }
   ```

6. 运行xv6并测试：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ pgtbltest
   ugetpid_test starting
   ugetpid_test: OK
   ...
   $
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

运行时发现`ugetpid`函数返回的是空值，不是当前进程的pid。

**解决方法：**

通过检查代码发现问题所在。

> 在`kernel/proc.c`的`proc_pagetable`函数中添加映射语句之前应该将p的syscall元素的pid设置为当前进程的pid。

#### 4) 实验心得

1. 对xv6的页面与页表之间的映射有了更好的理解。
1. 理解了加快系统调用的方法。



### 2. Print a page table (easy）

#### 1) 实验目的

实现一个打印页表的函数`vmprint`：打印第一个进程的页表信息。

#### 2) 实验步骤

1. 在`kernel/exec.c`的`exec`函数中添加以下语句调用`vmprint`：

   ```c
   int
   exec(char *path, char **argv)
   {
       ...
       if (p->pid == 1) {
     		vmprint(p->pagetable);
   	}
   
   	return argc; // this ends up in a0, the first argument to main(argc, argv)
       ...
       
   }
   ```

2. 在`kernel/defs.h`中添加`vmprint`的函数声明：

   ```c
   // vm.c
   ...
   void            vmprint(pagetable_t);
   ```

3. 在`kernel/vm.c`中添加`vmprint`的函数定义：

   ```c
   void
   vmprint_recursive(pagetable_t pagetable, int level, int max_level)
   {
     if (level > max_level) {
       return;
     }
   
     for (int i = 0; i < 512; i++) {
       pte_t pte = pagetable[i];
       if (pte & PTE_V) {
         for (int j = 0; j < level; j++) {
           if (level != 0) {
             printf(" ");
           }
           printf("..");
         }
         printf("%d: pte %p pa %p\n", i, pte, PTE2PA(pte));
   
         pagetable_t pagetable_next = (pagetable_t)PTE2PA(pte);
         vmprint_recursive(pagetable_next, level + 1, max_level);
       }
     }
   
     return;
   }
   
   // print the page table
   void
   vmprint(pagetable_t pagetable)
   {
     printf("page table %p\n", pagetable);
     vmprint_recursive(paetable, 1, 3);
   }
   ```

4. 运行xv6并测试：

   ```bash
   $ make qemu
   ...
   page table 0x0000000087f6e000
    ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
    .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
    .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
    .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
    .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
    ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
    .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
    .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
    .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
    .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
   init: starting sh
   $
   ```

#### 3) 实验中遇到的问题与解决方法

> 无

#### 4) 实验心得

1. 对xv6的页表与页面间的映射有了更好的理解。



### 3. Detecting which pages have been accessed (hard）

#### 1) 实验目的

实现xv6的系统调用`pgaccess`：获取当前被访问过的页面。

#### 2) 实验步骤

1. 在`kernel/riscv.h`的中添加`PTE_A`的定义 ：

   ```c
   #define PTE_A (1L << 6)
   ```

2. 在`kernel/sysproc.c`中添加`sys_pgaccess`的函数实现：

   ```c
   int
   sys_pgaccess(void)
   {
     // lab pgtbl: your code here.
     uint64 upg_addr;
     int pgnum;
     uint64 dst_addr;
     if (argaddr(0, &upg_addr) < 0) {
       return -1;
     }
     if (argint(1, &pgnum) < 0) {
       return -1;
     }
     if (argaddr(2, &dst_addr) < 0) {
       return -1;
     }
   
     uint64 bitmap = 0;
   
     struct proc* p = myproc();
     pagetable_t pagetable = p->pagetable;
   
     for (int i = 0; i < pgnum; i++) {
       pte_t* pte = walk(pagetable, upg_addr + PGSIZE * i, 1);
       if (*pte & PTE_A) {
         *pte = (*pte) & (~PTE_A);
         bitmap = bitmap | (1L << i);
       }
     }
   
     copyout(pagetable, dst_addr, (char*)&bitmap, sizeof(uint64));
   
     return 0;
   }
   ```

3. 运行xv6并测试：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ pgtbltest
   ugetpid_test starting
   ...
   pgaccess_test: OK
   pgtbltest: all tests succeeded
   $
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

PTE_A的值不知道该定义为几。

**解决方法：**

查询xv6 book，问题解决。

> 由xv6 book的图3.2可知，PTE_A是第6位，所以定义为`#define PTE_A (1L << 6)`

#### 4) 实验心得

通过此次实验，对xv6的页表机制理解更为深入了。



# Lab: traps

本实验的主要目的是了解xv6的`traps`如何实现系统调用。



### 1. RISC-V assembly (easy）

#### 1) 实验目的

阅读`call.asm`中函数`g`、`f`和`main`的代码，回答下列问题。

#### 2) 实验步骤

1. 执行`make fs.img`，在`user/call.asm`中生成可读的汇编版本。
2. 创建`answers-traps`，将问题的答案存储在其中。

#### 3) 实验中遇到的问题与解决方法

暂无

#### 4) 实验心得

通过此次实验，我对xv6的汇编语言以及系统调用过程有了更多的理解。



### 2. Backtrace (moderate)

#### 1) 实验目的

为xv6实现系统调用`backtrace()`：打印出栈上发生错误函数之前的所有函数。

#### 2) 实验步骤

1. 在`kernel/printf.c`中定义`backtrace`的函数实现：

   ```c
   void
   backtrace(void)
   {
     printf("backtrace:\n");
   
     uint64 fp = r_fp();
     uint64 down = PGROUNDDOWN(fp);
     uint64 up = PGROUNDUP(fp);
   
     while (fp > down && fp < up) {
       printf("%p\n", *((uint64*)(fp - 8)));
       fp = *((uint64*)(fp - 16));
     }
   }
   ```

2. 在`kernel/defs.h`中定义`backtrace`的函数声明：

   ```C
   // printf.c
   ...
   void            backtrace(void);
   ```

3. 在`kernel/sysproc.c`的`sys_sleep`函数中添加`backtrace`的函数调用：

   ```C
   uint64
   sys_sleep(void)
   {
   	...
   	backtrace();
   	...
   }
   ```

4. 运行xv6并测试：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ bttest
   backtrace:
   0x000000008000214a
   0x0000000080001fac
   0x0000000080001c96
   $
   ```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

对于固定偏移量-8和-16不知道该怎样使用。

**解决方法：**

通过查询网络资料解决了问题。

> 先将当前帧指针加上偏移量，再转换为指针类型，再取新指针指向的内容。

#### 4) 实验心得

在本次实验中，我更深入理解了操作系统内部的机制，特别是关于函数调用和栈帧的概念。

通过实现`backtrace()`系统调用，我学会了如何在一个现有的操作系统中扩展功能，这需要对系统内核的代码结构和运行时机制有深入的理解。在处理帧指针（`fp`）和调用栈链的时候，我遇到了一些挑战，但通过仔细分析和调试，最终成功地解决了问题。



### 3. Alarm (hard）

#### 1) 实验目的

为xv6实现系统调用`sigalarm`：每隔一段时间调用一个应用程序。

#### 2) 实验步骤

1. 在`user/user.h`中添加`sigalarm`和`sigreturn`的函数声明：

   ```c
   int sigalarm(int ticks, void (*handler)());
   int sigreturn(void);
   ```

2. 在`user/usys.pl`中添加以下语句，以更新汇编语言`usys.S`：

   ```perl
   entry("sigalarm");
   entry("sigreturn");
   ```

3. 在`kernel/syscall.h`中添加`sigalarm`和`sigreturn`的系统调用号：

   ```c
   #define SYS_sigalarm 22
   #define SYS_sigreturn 23
   ```

4. 在`kernel/syscall.c`的函数指针数组中加入`sigalarm`和`sigreturn`系统调用：

   ```c
   static uint64 (*syscalls[])(void) = {
   	...
   	[SYS_sigalarm] sys_sigalarm,
   	[SYS_sigreturn] sys_sigreturn,
   };
   ```

5. 在`kernel/syscall.c`中加入`sys_sigalarm`和`sys_sigreturn`的函数声明：

   ```c
   extern uint64 sys_sigalarm(void);
   extern uint64 sys_sigreturn(void);
   ```

6. 在`kernel/proc.h`中添加以下变量：

   ```C
   struct proc {
   	...
   	int alarm_interval;          // 报警间隔
     	void (*alarm_handler)();     // 处理函数
     	int ticks;                   // 已经过的时间
   };
   ```

7. 在`kernel/proc.c`中对上述变量初始化和释放：

   ```c
   static struct proc*
   allocproc(void)
   {
       ...
       p->alarm_interval = 0;
   	p->alarm_handler = 0;
   	p->ticks = 0;
   }
   
   static void
   freeproc(struct proc *p)
   {
   	...
       p->alarm_interval = 0;
   	p->alarm_handler = 0;
   	p->ticks = 0;
   }
   ```

8. 在`kernel/sysproc.c`中添加`sys_sigalarm`和`sys_sigreturn`的函数实现：

   ```C
   uint64
   sys_sigalarm(void)
   {
     int interval;
     if (argint(0, &interval) < 0)
       return -1;
   
     uint64 handler;
     if (argaddr(1, &handler) < 0)
       return -1;
   
     myproc()->alarm_interval = interval;
     myproc()->alarm_handler = handler;
   
     return 0;
   }
   
   uint64
   sys_sigreturn(void)
   {
   
     return 0;
   }
   ```

9. 在`kernel/trap.c`中修改`usertrap`：

   ```C
   if (which_dev == 2) {
     int ticks;
   
     if (p->alarm_intervel != 0&&++p->ticks==p->alarm_intervel) {
       p->ticks = 0;
       p->trapframe->epc = (uint64)p->alarm_handler;
     }
   
     yield();
   }
   ```

10. 以上`test0`完成。

11. 在`kernel/proc.h`中添加以下变量：

    ```c
    struct trapframe* alarm_trapframe;	//报警帧
    int is_alarming;             		//是否正在处理函数
    ```

12. 在`kernel/proc.c`中对上述变量初始化和释放：

    ```c
    static struct proc*
    allocproc(void)
    {
        ...
        if ((p->alarm_trapframe = (struct trapframe*)kalloc()) == 0) {
       		freeproc(p);
       		release(&p->lock);
       		return 0;
        }
        p->is_alarming = 0;
    }
    
    static void
    freeproc(struct proc *p)
    {
        ...
        if (p->alarm_trapframe)
      		kfree((void*)p->alarm_trapframe);
    		p->alarm_trapframe = 0;
        
        p->is_alarming = 0;
    }
    ```

13. 在`kernel/trap.c`中修改`usertrap`：

    ```c
    // give up the CPU if this is a timer interrupt.
    if (which_dev == 2) {
      if (p->alarm_interval != 0 && ++p->ticks == p->alarm_interval && p->is_alarming == 0) {
        memmove(p->alarm_trapframe, p->trapframe, sizeof(struct trapframe));
    
        p->ticks = 0;
        p->trapframe->epc = (uint64)p->alarm_handler;
    
        p->is_alarming = 1;
      }
    
      yield();
    }
    ```

14. 在`kernel/sysproc.c`中修改`sys_sigreturn`：

    ```C
    uint64
    sys_sigreturn(void)
    {
      memmove(myproc()->trapframe, myproc()->alarm_trapframe, sizeof(struct trapframe));
      myproc()->is_alarming = 0;
      return 0;
    }
    ```

15. 在Makefile文件的UPROGS中添加$U/_alarmtest\。

16. 运行xv6并测试alarmtest命令：

    ```bash
    $ make qemu
    ...
    init: starting sh
    $ alarmtest
    test0 start
    .alarm!
    test0 passed
    test1 start
    ..alarm!
    ..alarm!
    .alarm!
    .alarm!
    .alarm!
    .alarm!
    ..alarm!
    .alarm!
    ...alarm!
    alarm!
    test1 passed
    test2 start
    ..............alarm!
    test2 passed
    $
    ```

17. 测试程序得分：

```bash
$ ./grade-lab-traps alarm
```

或是

```bash
$ make GRADEFLAGS=alarm grade
```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

不知道什么决定了用户空间代码恢复执行的指令地址。

**解决方法：**

通过查询资料解决。

> proc的trapframe变量的epc属性决定了用户空间代码恢复执行的地址。

**问题2：**

在修改过代码后`test1`和`test2`依旧无法通过。

**解决方法：**

通过调试解决问题。

> 在usertrap函数中应该先进行memmove操作，再修改trapframe的epc。

#### 4) 实验心得

在本次实验中，我成功地为 xv6 操作系统实现了 `sigalarm` 系统调用，这为我带来了深刻的学习和技术挑战。通过这个过程，我深入理解了操作系统中信号处理的机制和系统调用的实现方式。

首先，理解和修改 xv6 操作系统的内核代码让我受益匪浅。我学习了如何在内核中注册新的系统调用，并实现了相应的内核函数来处理 `sigalarm` 调用。这个过程中，我不仅掌握了 xv6 内核的结构和设计理念，还学会了如何有效地利用现有的操作系统功能来扩展其功能。

其次，实现定时器和信号处理的功能是本次实验的重点。我深入研究了 xv6 中关于定时器和信号处理的实现方式，理解了用户态和内核态之间数据交换的机制。通过实现 `sigalarm`，我加强了对操作系统中定时任务调度和用户程序管理的理解。

在解决实验过程中遇到的问题时，我通过仔细分析文档和源代码，并利用调试工具逐步解决了问题。这种挑战性的实验不仅提升了我的编程技能，还锻炼了我解决复杂问题的能力和耐心。



# Lab: Copy-on-Write Fork for xv6

本实验的主要目的是了解xv6的PTE。



### 1. RISC-V assembly (easy）

#### 1) 实验目的

实现`Copy-on-Write Fork`。

#### 2) 实验步骤

1. 在`kernel/riscv.h`中加入PTE保留位`PTE_F`来标记一个页面是否为COW Fork页面：

   ```c
   #define PTE_F (1L << 8)
   ```

2. 修改`kerenl/vm.c`中的`uvmcopy`函数，在copy时不为子进程分配内存，而是父子进程共享内存：

   ```C
   int
   uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   {
     pte_t *pte;
     uint64 pa, i;
     uint flags;
   
     for(i = 0; i < sz; i += PGSIZE){
       if((pte = walk(old, i, 0)) == 0)
         panic("uvmcopy: pte should exist");
       if((*pte & PTE_V) == 0)
         panic("uvmcopy: page not present");
       pa = PTE2PA(*pte);
       flags = PTE_FLAGS(*pte);
   
       if (flags & PTE_W) {
         flags = (flags | PTE_F) & ~PTE_W;
         *pte = PA2PTE(pa) | flags;
       }
   
       if (mappages(new, i, PGSIZE, pa, flags) != 0) {
         goto err;
       }
     }
     return 0;
   
    err:
     uvmunmap(new, 0, i / PGSIZE, 1);
     return -1;
   }
   ```

3. 在`kernel/kalloc.c`中添加如下修改：

   ```c
   struct ref_stru {
       struct spinlock lock;
     	int cnt[PHYSTOP / PGSIZE];
   }ref;
   
   void
   kinit()
   {
       ...
     	initlock(&ref.lock, "ref");
     	...
   }
   
   void *
   kalloc(void)
   {
       ...
   	if (r) {
           kmem.freelist = r->next;
     		acquire(&ref.lock);
     		ref.cnt[(uint64)r / PGSIZE] = 1;
     		release(&ref.lock);
   	}
       ...
   }
   
   void
   kfree(void *pa)
   {
       acquire(&ref.lock);
   	if (--ref.cnt[(uint64)pa / PGSIZE] == 0) {
     		release(&ref.lock);
   
     		// Fill with junk to catch dangling refs.
     		memset(pa, 1, PGSIZE);
   
     		r = (struct run*)pa;
   
     		acquire(&kmem.lock);
     		r->next = kmem.freelist;
     		kmem.freelist = r;
     		release(&kmem.lock);
   	}
   	else {
     		release(&ref.lock);
   	}
   }
   
   void
   freerange(void *pa_start, void *pa_end)
   {
       ...
     	for (; p + PGSIZE <= (char*)pa_end; p += PGSIZE) {
       	ref.cnt[(uint64)p / PGSIZE] = 1;
       	kfree(p);
     	}
   }
   ```

4. 在`kernel/kalloc.c`中添加以下函数：

   ```c
   int             is_cowpage(pagetable_t pagetable, uint64 va);	//判断是否为cow
   void*           cowalloc(pagetable_t pagetable, uint64 va);		//cow分配器
   int             krefcnt(void* pa);								//获取引用次数
   int             kaddrefcnt(void* pa);							//增加引用次数
   ```

5. 在`kernel/trap.c`中修改`usertrap`函数：

   ```C
   ...
   else if (cause == 13 || cause == 15) {
     uint64 fault_va = r_stval();
     if (fault_va >= p->sz || is_cowpage(p->pagetable, fault_va) != 0 || cowalloc(p->pagetable, PGROUNDDOWN(fault_va)) == 0) {
       p->killed = 1;
     }
   }
   ...
   ```

6. 在`kernel/vm.c`中修改`copyout`函数：

   ```c
   ...
   if (is_cowpage(pagetable, va0) == 0) {
     // 更换目标物理地址
     pa0 = (uint64)cowalloc(pagetable, va0);
   }
   ...
   ```

7. 运行xv6并测试cowtest命令：

   ```bash
   $ make qemu
   ...
   init: starting sh
   $ cowtest
   simple: ok
   simple: ok
   three: ok
   three: ok
   three: ok
   file: ok
   ALL COW TESTS PASSED
   $
   ```

8. 测试程序得分：

```bash
$ make grade
```

#### 3) 实验中遇到的问题与解决方法

**问题1：**

未在`freerange`函数中对cnt赋值为1，导致运行失败。

**解决方法：**

通过调试发现问题所在。

> `kinit`函数会调用`freerange`函数，进行`kfree`，所以应该先将cnt赋值为1。

**问题2：**

在涉及va时未检查是否超出MAXVA、va页是否对齐，涉及pte未检查是否有效、是否未找到。

**解决方法：**

> 在涉及va、pte、pa等时，应该进行规范检查。

#### 4) 实验心得

在这次操作系统实验中，深入研究了copy-on-write（COW）fork()机制。COW fork()通过延迟实际的物理内存复制，有效地节省了内存和时间。观察到，在父子进程共享内存页时，只有当其中一个进程尝试写入时，才会进行物理页的复制，这显著提高了进程复制的效率。然而，这种机制也引入了页面错误处理和资源释放的复杂性，需要操作系统在内存管理上做出额外的考量。通过这个实验，我深入理解了COW在操作系统中的应用及其带来的性能优势和管理挑战。



